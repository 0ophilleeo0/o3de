/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
#pragma once

#include <Atom/RHI.Reflect/ShaderStageLibrary.h>

namespace AZ
{
    class ReflectContext;

    template <typename, typename>
    struct AnyTypeInfoConcept;

    namespace Serialize
    {
        template <typename, bool, bool>
        struct InstanceFactory;
    }

    namespace Provo
    {
        class ShaderStageFunction;

        /**
         * DirectX uses HLSL, which relies on independent byte code chunks generated by the preprocessor. It
         * does not support specialization via function constants (yet). Therefore, this implementation is
         * trivially simple, basically wrapping an unordered_map. There is no byte code shared between functions;
         * each function has its own local vector of opaque byte code data.
         *
         * Building the library is simple. Call MakeFunction with a new ID to get an empty ShaderStageFunction
         * instance. Then, assign the byte codes directly on the ShaderStageFunction instance. Make sure to call
         * Finalize on both the function and library after you are finished.
         *
         * Building Example:
         *
         *  Data::AssetId libraryAssetId = ...;
         *
         *  // Picked tessellation because it's the more complex example.
         *  auto lib = AZStd::make_shared<DX12::ShaderStageLibrary>();
         *
         *  auto* tessellationFunction = lib->MakeFunction(RHI::ShaderStageFunctionId(libraryAssetId.m_guid, SUB_ID), RHI::ShaderStage::Tessellation);
         *  tessellationFunction->SetByteCode(DX12::ShaderSubStage::TessellationHull, AZStd::move(hullShaderByteCode));
         *  tessellationFunction->SetByteCode(DX12::ShaderSubStage::TessellationDomain, AZStd::move(domainShaderByteCode));
         *  tessellationFunction->Finalize();
         *
         *  // The tessellation function is now ready. You can add more functions with unique ids. Here we'll just finalize
         *  // the library.
         *  lib->Finalize();
         *
         *  // Serialize the library.
         *
         * Runtime Usage Example:
         *
         *  auto lib = SerializeLibrary();
         *
         *  // Don't forget to call this once after serialization.
         *  lib->FinalizeAfterLoad();
         *
         *  // Assumes you stored the function id on an asset somewhere.
         *  auto* tessellationFunction = lib->FindFunction(tessellationFunctionId);
         *
         *  RHI::PipelineStateDrawDescriptor psoDesc;
         *
         *  tessellationFunction->ConfigurePipelineStateObject(psoDesc);
         */
        class ShaderStageLibrary final
            : public RHI::ShaderStageLibrary
        {
        public:
            AZ_RTTI(ShaderStageLibrary, "{80ED8291-8A3A-4D0C-9023-25E6B78C6EA3}", RHI::ShaderStageLibrary);
            AZ_CLASS_ALLOCATOR(ShaderStageLibrary, AZ::SystemAllocator, 0);
            static void Reflect(AZ::ReflectContext* context);

            static RHI::Ptr<ShaderStageLibrary> Create();

            /**
             * Makes an empty function at the specified id. If the function already exists at the
             * specified id, it is replaced with an empty one.
             */
            ShaderStageFunction* MakeFunction(const RHI::ShaderStageFunctionId& id, RHI::ShaderStage stage);

        private:
            ShaderStageLibrary() = default;

            //////////////////////////////////////////////////////////////////////////
            // Serialization System Friends
            template <typename, typename>
            friend struct AZ::AnyTypeInfoConcept;

            template <typename, bool, bool>
            friend struct AZ::Serialize::InstanceFactory;
            //////////////////////////////////////////////////////////////////////////

            ///////////////////////////////////////////////////////////////////
            // RHI::ShaderStageLibrary
            const RHI::ShaderStageFunction* FindFunctionInternal(const RHI::ShaderStageFunctionId& id) const override;
            RHI::ResultCode FinalizeInternal() override;
            RHI::ResultCode FinalizeAfterLoadInternal() override;
            ///////////////////////////////////////////////////////////////////

            AZStd::unordered_map<RHI::ShaderStageFunctionId, ShaderStageFunction> m_functions;
        };
    }
}
