/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

#include <Atom/Features/PBR/LightingOptions.azsli>

#include <viewsrg.srgi>
#include <scenesrg.srgi>

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>

#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/PBR/ForwardPassSrg.azsli>

#include <Atom/Features/PBR/Lighting/StandardLighting.azsli>
#include <Atom/Features/PBR/Decals.azsli>



// DEPRECATED: Please use the functions in StandardLighting.azsli instead.
// For an example on how to use those functions, see StandardPBR_forwardPass.azsl
// PbrLightingOutput PbrLighting(  VSOutput IN,
//                                 float3 baseColor,
//                                 float metallic,
//                                 float roughness,
//                                 float specularF0Factor,
//                                 float3 normal,
//                                 float3 vtxTangent,
//                                 float3 vtxBitangent,
//                                 float2 anisotropy,  // angle and factor
//                                 float3 emissive,
//                                 float occlusion,
//                                 float4 transmissionTintThickness,
//                                 float4 transmissionParams,
//                                 float clearCoatFactor,
//                                 float clearCoatRoughness,
//                                 float3 clearCoatNormal,
//                                 float alpha,
//                                 OpacityMode opacityMode)
// {
//     float3 worldPosition = IN.m_worldPosition;
//     float4 position = IN.m_position;
//     float3 shadowCoords[ViewSrg::MaxCascadeCount] = IN.m_shadowCoords;
// 
//     // ______________________________________________________________________________________________
//     // Surface
// 
//     Surface surface;
// 
//     surface.position = worldPosition;
//     surface.normal = normal;
//     surface.roughnessLinear = roughness;
//     surface.transmission.tint = transmissionTintThickness.rgb;
//     surface.transmission.thickness = transmissionTintThickness.w;
//     surface.transmission.transmissionParams = transmissionParams;
//     surface.clearCoat.factor = clearCoatFactor;
//     surface.clearCoat.roughness = clearCoatRoughness;
//     surface.clearCoat.normal = clearCoatNormal;
// 
//     surface.CalculateRoughnessA();
//     surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);
//     surface.anisotropy.Init(normal, vtxTangent, vtxBitangent, anisotropy.x, anisotropy.y, surface.roughnessA);
// 
//     // ______________________________________________________________________________________________
//     // LightingData
// 
//     LightingData lightingData;
// 
//     // Light iterator
//     lightingData.tileIterator.Init(position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
//     lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);
//     
//     lightingData.emissiveLighting = emissive;
//     lightingData.occlusion = occlusion;
// 
//     // Directional light shadow coordinates
//     lightingData.shadowCoords = shadowCoords;
// 
//     // manipulate base layer f0 if clear coat is enabled
//     if(o_clearCoat_feature_enabled)
//     {
//         // modify base layer's normal incidence reflectance
//         // for the derivation of the following equation please refer to:
//         // https://google.github.io/filament/Filament.md.html#materialsystem/clearcoatmodel/baselayermodification
//         float3 f0 = (1.0 - 5.0 * sqrt(surface.specularF0)) / (5.0 - sqrt(surface.specularF0));
//         surface.specularF0 = lerp(surface.specularF0, f0 * f0, clearCoatFactor);
//     }
// 
//     // Diffuse and Specular response (used in IBL calculations)
//     lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
//     lightingData.diffuseResponse = 1.0 - lightingData.specularResponse;
// 
//     if(o_clearCoat_feature_enabled)
//     {
//         // Clear coat layer has fixed IOR = 1.5 and transparent => F0 = (1.5 - 1)^2 / (1.5 + 1)^2 = 0.04
//         lightingData.diffuseResponse *= 1.0 - (FresnelSchlickWithRoughness(lightingData.NdotV, float3(0.04, 0.04, 0.04), surface.clearCoat.roughness) * surface.clearCoat.factor);
//     }
// 
//     // Multiscatter compensation factor
//     lightingData.CalculateMultiscatterCompensation(surface.specularF0, o_specularF0_enableMultiScatterCompensation);
// 
//     // ______________________________________________________________________________________________
//     // Lighting
// 
//     // Apply Decals
//     ApplyDecals(lightingData.tileIterator, surface);
// 
//     // Apply Direct Lighting
//     ApplyDirectLighting(surface, lightingData);
// 
//     // Apply Image Based Lighting (IBL)
//     ApplyIBL(surface, lightingData);
// 
//     // Finalize Lighting
//     lightingData.FinalizeLighting(surface.transmission.tint);
// 
//     if (o_opacity_mode == OpacityMode::Blended || o_opacity_mode == OpacityMode::TintedTransparent)
//     {
//         alpha = FresnelSchlickWithRoughness(lightingData.NdotV, alpha, surface.roughnessLinear).x; // Increase opacity at grazing angles.
//     }
// 
//     PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);
// 
//     return lightingOutput;
// }

