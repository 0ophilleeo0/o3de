/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

#include <Atom/RPI/Math.azsli>
#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
#include <Atom/Features/PBR/LightingUtils.azsli>

void ApplyIblDiffuse(Surface surface, float3 diffuseResponse, out float3 outDiffuse)
{
    float3 irradianceDir = MultiplyVectorQuaternion(surface.normal, SceneSrg::m_iblOrientation);
    float3 diffuseSample = SceneSrg::m_diffuseEnvMap.Sample(SceneSrg::m_samplerEnv, GetCubemapCoords(irradianceDir)).rgb;

    outDiffuse = diffuseResponse * surface.albedo * diffuseSample;
}

void ApplyIblSpecular(Surface surface, float3 specularResponse, float3 dirToCamera, float2 brdf, out float3 outSpecular)
{
    float3 reflectDir = reflect(-dirToCamera, surface.normal);
    
    // global
    outSpecular = SceneSrg::m_specularEnvMap.SampleLevel(SceneSrg::m_samplerEnv, GetCubemapCoords(reflectDir), GetRoughnessMip(surface.roughnessLinear)).rgb;
    outSpecular *= (surface.specularF0 * brdf.x + brdf.y);
    
    // reflection probe
    if (ObjectSrg::m_reflectionProbeData.m_useReflectionProbe)
    {
        if (ObjectSrg::m_reflectionProbeData.m_useParallaxCorrection)
        {
            reflectDir = ApplyParallaxCorrection(
                ObjectSrg::m_reflectionProbeData.m_outerAabbMin, 
                ObjectSrg::m_reflectionProbeData.m_outerAabbMax, 
                ObjectSrg::m_reflectionProbeData.m_aabbPos, 
                surface.position, 
                reflectDir);
        }
    
        float3 probeSpecular = ObjectSrg::m_reflectionProbeCubeMap.SampleLevel(SceneSrg::m_samplerEnv, GetCubemapCoords(reflectDir), GetRoughnessMip(surface.roughnessLinear)).rgb;
        probeSpecular *= (surface.specularF0 * brdf.x + brdf.y);
    
        // compute blend amount based on world position in the reflection probe volume
        float blendAmount = ComputeLerpBetweenInnerOuterAABBs(
            ObjectSrg::m_reflectionProbeData.m_innerAabbMin, 
            ObjectSrg::m_reflectionProbeData.m_innerAabbMax, 
            ObjectSrg::m_reflectionProbeData.m_outerAabbMax, 
            ObjectSrg::m_reflectionProbeData.m_aabbPos, 
            surface.position);
    
        outSpecular = lerp(outSpecular, probeSpecular, blendAmount);
    }
}