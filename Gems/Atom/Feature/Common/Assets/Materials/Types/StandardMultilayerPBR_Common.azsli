/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once 

#include <Atom/Features/SrgSemantics.azsli>
#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>
#include <Atom/Features/PBR/LightingOptions.azsli>

#include "MaterialInputs/BaseColorInput.azsli"
#include "MaterialInputs/RoughnessInput.azsli"
#include "MaterialInputs/MetallicInput.azsli"
#include "MaterialInputs/SpecularInput.azsli"
#include "MaterialInputs/NormalInput.azsli"
#include "MaterialInputs/ClearCoatInput.azsli"
#include "MaterialInputs/OcclusionInput.azsli"
#include "MaterialInputs/EmissiveInput.azsli"
#include "MaterialInputs/ParallaxInput.azsli"
#include "MaterialInputs/UvSetCount.azsli"

// ------ ShaderResourceGroup ----------------------------------------

#define DEFINE_LAYER_SRG_INPUTS(prefix) \
COMMON_SRG_INPUTS_BASE_COLOR(prefix)    \
COMMON_SRG_INPUTS_ROUGHNESS(prefix)     \
COMMON_SRG_INPUTS_METALLIC(prefix)      \
COMMON_SRG_INPUTS_SPECULAR_F0(prefix)   \
COMMON_SRG_INPUTS_NORMAL(prefix)        \
COMMON_SRG_INPUTS_CLEAR_COAT(prefix)    \
COMMON_SRG_INPUTS_OCCLUSION(prefix)     \
COMMON_SRG_INPUTS_EMISSIVE(prefix)      \
COMMON_SRG_INPUTS_PARALLAX(prefix)

ShaderResourceGroup MaterialSrg : SRG_PerMaterial
{
    Texture2D m_blendMaskTexture;
    uint m_blendMaskUvIndex;
    
    // When parallax mapping is used, these limit the heightmap intersection search range to the narrowest band possible, to give the best quality result.
    // These are also support other calculations related to displacement-based blending, even when parallax is not used.
    float m_displacementMin; // The lowest displacement value possible from all layers combined (negative values are below the surface)
    float m_displacementMax; // The highest displacement value possible from all layers combined (negative values are below the surface)
    
    float m_displacementBlendFactor;

    // Auto-generate material SRG fields for common inputs for each layer
    DEFINE_LAYER_SRG_INPUTS(m_layer1_)
    DEFINE_LAYER_SRG_INPUTS(m_layer2_)
    DEFINE_LAYER_SRG_INPUTS(m_layer3_)
    
    float3x3 m_layer1_m_uvMatrix;
    float4 m_pad1; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.

    float3x3 m_layer2_m_uvMatrix;
    float4 m_pad2; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.

    float3x3 m_layer3_m_uvMatrix;
    float4 m_pad3; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    
    uint m_parallaxUvIndex;

    float3x3 m_uvMatrix;
    float4 m_pad4; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    float3x3 m_uvMatrixInverse;
    float4 m_pad5; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    
    Sampler m_sampler
    {
        AddressU = Wrap;
        AddressV = Wrap;
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        MaxAnisotropy = 16;
    };

    Texture2D m_brdfMap;

    Sampler m_samplerBrdf
    {
        AddressU = Clamp;
        AddressV = Clamp;
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
    };

}

// ------ Shader Options ----------------------------------------

option bool o_layer2_enabled;
option bool o_layer3_enabled;

enum class DebugDrawMode { None, BlendMask, Displacement, FinalBlendWeights };
option DebugDrawMode o_debugDrawMode;

enum class LayerBlendSource { BlendMaskTexture, BlendMaskVertexColors, Displacement, Displacement_With_BlendMaskTexture, Displacement_With_BlendMaskVertexColors, Fallback };
option LayerBlendSource o_layerBlendSource;

// Indicates whether the vertex input struct's "m_optional_blendMask" is bound. If false, it is not safe to read from m_optional_blendMask.
// This option gets set automatically by the system at runtime; there is a soft naming convention that associates it with m_optional_blendMask.
// (search "m_optional_" in ShaderVariantAssetBuilder for details on the naming convention).
// [GFX TODO][ATOM-14475]: Come up with a more elegant way to associate the isBound flag with the input stream.
option bool o_blendMask_isBound;

// ------ Blend Utilities ----------------------------------------
// This is mainly used to pass extra data to the GetDepth callback function during the parallax depth search.
// But since we have it, we use it in some other functions as well rather than passing it around.
static float3 s_blendMaskFromVertexStream;

// TODO: Consider storing the result of GetFinalLayerBlendSource() in a static similar to s_blendMaskFromVertexStream. That might give better performance when variants aren't used.

//! Returns the LayerBlendSource that will actually be used when rendering (not necessarily the same LayerBlendSource specified by the user)
LayerBlendSource GetFinalLayerBlendSource()
{    
    if(o_layerBlendSource == LayerBlendSource::BlendMaskTexture)
    {
        return o_layerBlendSource;
    }
    else if(o_layerBlendSource == LayerBlendSource::BlendMaskVertexColors)
    {
        if(o_blendMask_isBound)
        {
            return o_layerBlendSource;
        }
        else
        {
            return LayerBlendSource::Fallback;
        }
    }
    else if(o_layerBlendSource == LayerBlendSource::Displacement)
    {
        return o_layerBlendSource;
    }
    else if(o_layerBlendSource == LayerBlendSource::Displacement_With_BlendMaskTexture)
    {
        return o_layerBlendSource;
    }
    else if(o_layerBlendSource == LayerBlendSource::Displacement_With_BlendMaskVertexColors)
    {
        if(o_blendMask_isBound)
        {
            return o_layerBlendSource;
        }
        else
        {
            return LayerBlendSource::Displacement;
        }
    }
    else
    {
        return LayerBlendSource::Fallback;
    }
}

//! Return the applicable blend mask values from the blend mask texture or vertex colors, and filters out any that don't apply.
//!     layer1 is an implicit base layer
//!     layer2 mask is in the r channel
//!     layer3 mask is in the g channel
//!     b is reserved for perhaps a dedicated puddle layer
//! @param blendSource indicates where to get the blend mask from
//! @param blendMaskUv for sampling a blend mask texture, if that's the blend source
//! @param blendMaskVertexColors the vertex color values to use for the blend mask, if that's the blend source
//! @return the blend mask values, or 0 if there is no blend mask
float3 GetApplicableBlendMaskValues(LayerBlendSource blendSource, float2 blendMaskUv, float3 blendMaskVertexColors)
{
    float3 blendSourceValues = float3(0,0,0);

    if(o_layer2_enabled || o_layer3_enabled)
    {
        switch(blendSource)
        {
            case LayerBlendSource::Displacement:
                // In this case the blend mask has no effect, returning (1,1,1) disables any impact of the mask.
                blendSourceValues = float3(1,1,1);
                break;
            case LayerBlendSource::BlendMaskTexture:
            case LayerBlendSource::Displacement_With_BlendMaskTexture:
                blendSourceValues = MaterialSrg::m_blendMaskTexture.Sample(MaterialSrg::m_sampler, blendMaskUv).rgb;
                break;
            case LayerBlendSource::BlendMaskVertexColors:
            case LayerBlendSource::Displacement_With_BlendMaskVertexColors:
                blendSourceValues = blendMaskVertexColors;
                break;
        }

        if(!o_layer2_enabled)
        {
            blendSourceValues.r = 0.0;
        }

        if(!o_layer3_enabled)
        {
            blendSourceValues.g = 0.0;
        }
    }

    return blendSourceValues;
}

//! Returns blend weights given the depth values for each layer
//! @param layerDepthValues - the per-layer depth values as provided by GetLayerDepthValues()
//! @param layerDepthBlendFactor - controls how smoothly to blend layers 2 and 3 with the base layer.
//!                                when layers are close together their weights will be blended together, otherwise the highest layer will have the full weight.
float3 GetBlendWeightsFromLayerDepthValues(float3 layerDepthValues, float layerDepthBlendFactor)
{
    if(!o_layer2_enabled && !o_layer3_enabled)
    {
        return float3(1,0,0);
    }
    else
    {
        // The inputs are depth values, but we change them to height values to make the code a bit more intuitive.
        float3 layerHeightValues = -layerDepthValues;

        float highestPoint = layerHeightValues.x;
        if(o_layer2_enabled)
        {
            highestPoint = max(highestPoint, layerHeightValues.y);
        }
        if(o_layer3_enabled)
        {
            highestPoint = max(highestPoint, layerHeightValues.z);
        }

        float3 blendWeights;

        if(layerDepthBlendFactor > 0.001)
        {
            float blendDistance = (MaterialSrg::m_displacementMax - MaterialSrg::m_displacementMin) * layerDepthBlendFactor;
        
            // The blend weights are adjusted to give a smooth transition in the surface appearance.
            float lowestVisiblePoint = highestPoint - blendDistance;

            blendWeights = saturate(layerHeightValues - lowestVisiblePoint) / blendDistance;
            
            if(!o_layer2_enabled)
            {
                blendWeights.y = 0.0;
            }

            if(!o_layer3_enabled)
            {
                blendWeights.z = 0.0;
            }

            blendWeights = blendWeights / (blendWeights.x + blendWeights.y + blendWeights.z);
        }
        else
        {
            blendWeights = float3(layerHeightValues.x >= highestPoint ? 1.0 : 0.0,
                                  layerHeightValues.y >= highestPoint && o_layer2_enabled ? 1.0 : 0.0,
                                  layerHeightValues.z >= highestPoint && o_layer3_enabled ? 1.0 : 0.0);
        }
    
        return blendWeights;
    }

}

//! Return the final blend weights to be used for rendering, based on the available data and configuration.
//! @param blendSource - indicates where to get the blend mask from
//! @param blendMaskUv - for sampling a blend mask texture, if that's the blend source
//! @param blendMaskVertexColors - the vertex color values to use for the blend mask, if that's the blend source
//! @param layerDepthValues - the depth values for each layer, used if the blend source includes displacement. See GetLayerDepthValues().
//! @param layerDepthBlendFactor - controls how smoothly to blend layers 2 and 3 with the base layer, when the blend source includes displacement. See GetLayerDepthValues().
//! @return The blend weights for each layer.
//!         Even though layer1 not explicitly specified in the blend mask data, it is explicitly included with the returned values.
//!         layer1 = r
//!         layer2 = g
//!         layer3 = b
float3 GetBlendWeights(LayerBlendSource blendSource, float2 blendMaskUv, float3 blendMaskVertexColors, float3 layerDepthValues, float layerDepthBlendFactors)
{
    float3 blendWeights;
    
    if(o_layer2_enabled || o_layer3_enabled)
    {
        if(LayerBlendSource::Displacement == blendSource || 
           LayerBlendSource::Displacement_With_BlendMaskTexture == blendSource || 
           LayerBlendSource::Displacement_With_BlendMaskVertexColors == blendSource)
        {
            // Note that any impact from the blend mask will have already been applied to these layerDepthValues in GetLayerDepthValues().
            // So even though there is no blend mask code here, the blend mask is being applied when enabled.
            blendWeights = GetBlendWeightsFromLayerDepthValues(layerDepthValues, layerDepthBlendFactors);
        }
        else
        {
            float3 blendMaskValues = GetApplicableBlendMaskValues(blendSource, blendMaskUv, blendMaskVertexColors);

            // Calculate blend weights such that multiplying and adding them with layer data is equivalent
            // to lerping between each layer.
            //     final = lerp(final, layer1, blendWeights.r)
            //     final = lerp(final, layer2, blendWeights.g)
            //     final = lerp(final, layer3, blendWeights.b)

            blendWeights.b = blendMaskValues.g;
            blendWeights.g = (1.0 - blendMaskValues.g) * blendMaskValues.r;
            blendWeights.r = (1.0 - blendMaskValues.g) * (1.0 - blendMaskValues.r);
        }

    }
    else
    {
        blendWeights = float3(1,0,0);
    }

    return blendWeights;
}

float3 GetLayerDepthValues(LayerBlendSource blendSource, float2 uv, float2 uv_ddx, float2 uv_ddy, float3 blendMaskVertexColors);

//! Return the final blend weights to be used for rendering, based on the available data and configuration.
//! Note this will sample the displacement maps in the case of LayerBlendSource::Displacement. If you have already
//! called GetLayerDepthValues(), use the GetBlendWeights() overload that takes layerDepthValues instead.
float3 GetBlendWeights(LayerBlendSource blendSource, float2 uv, float3 blendMaskVertexColors)
{
    float3 layerDepthValues = float3(0,0,0);

    if(blendSource == LayerBlendSource::Displacement ||
       blendSource == LayerBlendSource::Displacement_With_BlendMaskTexture ||
       blendSource == LayerBlendSource::Displacement_With_BlendMaskVertexColors)
    {
        layerDepthValues = GetLayerDepthValues(blendSource, uv, ddx_fine(uv), ddy_fine(uv), blendMaskVertexColors);
    }

    return GetBlendWeights(blendSource, uv, blendMaskVertexColors, layerDepthValues, MaterialSrg::m_displacementBlendFactor);
}

float BlendLayers(float layer1, float layer2, float layer3, float3 blendWeights)
{
    return dot(float3(layer1, layer2, layer3), blendWeights);
}
float2 BlendLayers(float2 layer1, float2 layer2, float2 layer3, float3 blendWeights)
{
    return layer1 * blendWeights.r + layer2 * blendWeights.g + layer3 * blendWeights.b;
}
float3 BlendLayers(float3 layer1, float3 layer2, float3 layer3, float3 blendWeights)
{
    return layer1 * blendWeights.r + layer2 * blendWeights.g + layer3 * blendWeights.b;
}

// ------ Parallax Utilities ----------------------------------------

bool ShouldHandleParallax()
{
    // Parallax mapping's non uniform uv transformations break screen space subsurface scattering, disable it when subsurface scattering is enabled.
    // Also, all the debug draw modes avoid parallax (they early-return before parallax code actually) so you can see exactly where the various maps appear on the surface UV space.
    return !o_enableSubsurfaceScattering && o_parallax_feature_enabled && o_debugDrawMode == DebugDrawMode::None;
}

bool ShouldHandleParallaxInDepthShaders()
{
    // The depth pass shaders need to calculate parallax when the result could affect the depth buffer (or when
    // parallax could affect texel clipping but we don't have alpha/clipping support in multilayer PBR).
    return ShouldHandleParallax() && o_parallax_enablePixelDepthOffset;
}

//! Returns the depth values for each layer.
//! If the blend source is Displacement_With_BlendMaskTexture or Displacement_With_BlendMaskVertexColors, this will use the blend weights to further offset the depth values.
float3 GetLayerDepthValues(LayerBlendSource blendSource, float2 uv, float2 uv_ddx, float2 uv_ddy, float3 blendMaskVertexColors)
{
    float3 layerDepthValues = float3(0,0,0);
    
    bool useLayer1 = true;
    bool useLayer2 = (o_layer2_enabled && o_layer2_o_useDepthMap);
    bool useLayer3 = (o_layer3_enabled && o_layer3_o_useDepthMap);

    if(useLayer1)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer1_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.r = SampleDepthOrHeightMap(MaterialSrg::m_layer1_m_depthInverted, MaterialSrg::m_layer1_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.r *= MaterialSrg::m_layer1_m_depthFactor;
        layerDepthValues.r -= MaterialSrg::m_layer1_m_depthOffset;
    }
    
    if(useLayer2)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer2_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.g = SampleDepthOrHeightMap(MaterialSrg::m_layer2_m_depthInverted, MaterialSrg::m_layer2_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.g *= MaterialSrg::m_layer2_m_depthFactor;
        layerDepthValues.g -= MaterialSrg::m_layer2_m_depthOffset;

    }
    
    if(useLayer3)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer3_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.b = SampleDepthOrHeightMap(MaterialSrg::m_layer3_m_depthInverted, MaterialSrg::m_layer3_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.b *= MaterialSrg::m_layer3_m_depthFactor;
        layerDepthValues.b -= MaterialSrg::m_layer3_m_depthOffset;

    }
    
    bool useBlendMask = 
       LayerBlendSource::Displacement_With_BlendMaskTexture == blendSource || 
       LayerBlendSource::Displacement_With_BlendMaskVertexColors == blendSource;

    if(useBlendMask && (useLayer2 || useLayer3))
    {
        // We use the blend mask to lower each layer's surface so that it disappears under the other surfaces.
        // Note the blend mask does not apply to the first layer, it is the implicit base layer. Layers 2 and 3 are masked by the r and g channels.

        float3 blendMaskValues = GetApplicableBlendMaskValues(blendSource, uv, blendMaskVertexColors);
        
        // We add to the depth value rather than lerp toward m_displacementMin to avoid squashing the topology, but instead lower it out of sight.

        // We might want to consider other approaches to the blend mask factors. They way they work now allows the user to lower

        if(useLayer2)
        {
            float dropoffRange = MaterialSrg::m_layer2_m_depthOffset - MaterialSrg::m_displacementMin;
            layerDepthValues.g += dropoffRange * (1-blendMaskValues.r);
        }
        
        if(useLayer3)
        {
            float dropoffRange = MaterialSrg::m_layer3_m_depthOffset - MaterialSrg::m_displacementMin;
            layerDepthValues.b += dropoffRange * (1-blendMaskValues.g);
        }
    }


    return layerDepthValues;
}

//! Callback function for ParallaxMapping.azsli
DepthResult GetDepth(float2 uv, float2 uv_ddx, float2 uv_ddy)
{
    LayerBlendSource blendSource = GetFinalLayerBlendSource();

    float3 layerDepthValues = GetLayerDepthValues(blendSource, uv, uv_ddx, uv_ddy, s_blendMaskFromVertexStream);
    
    // When blending the depth together, we don't use MaterialSrg::m_displacementBlendFactor. The intention is that m_displacementBlendFactor
    // is for transitioning the appearance of the surface itself, but we still want a distinct change in the heightmap. If someday we want to 
    // support smoothly blending the depth as well, there is a bit more work to do to get it to play nice with the blend mask code in GetLayerDepthValues().
    float layerDepthBlendFactor = 0.0f;

    // Note, when the blend source uses the blend mask from the vertex colors, parallax will not be able to blend correctly between layers. It will end up using the same blend mask values
    // for every UV position when searching for the intersection. This leads to smearing artifacts at the transition point, but these won't be as noticeable if
    // you have a small depth factor relative to the size of the blend transition.
    float3 blendWeightValues = GetBlendWeights(blendSource, uv, s_blendMaskFromVertexStream, layerDepthValues, layerDepthBlendFactor);

    float depth = BlendLayers(layerDepthValues.r, layerDepthValues.g, layerDepthValues.b, blendWeightValues);
    return DepthResultAbsolute(depth);
}
