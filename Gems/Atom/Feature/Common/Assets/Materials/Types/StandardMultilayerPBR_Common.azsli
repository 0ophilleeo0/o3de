/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once 

#include <Atom/Features/SrgSemantics.azsli>
#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>
#include <Atom/Features/PBR/LightingOptions.azsli>

#include "MaterialInputs/BaseColorInput.azsli"
#include "MaterialInputs/RoughnessInput.azsli"
#include "MaterialInputs/MetallicInput.azsli"
#include "MaterialInputs/SpecularInput.azsli"
#include "MaterialInputs/NormalInput.azsli"
#include "MaterialInputs/ClearCoatInput.azsli"
#include "MaterialInputs/OcclusionInput.azsli"
#include "MaterialInputs/EmissiveInput.azsli"
#include "MaterialInputs/ParallaxInput.azsli"
#include "MaterialInputs/UvSetCount.azsli"

// ------ ShaderResourceGroup ----------------------------------------

#define DEFINE_LAYER_SRG_INPUTS(prefix) \
COMMON_SRG_INPUTS_BASE_COLOR(prefix)    \
COMMON_SRG_INPUTS_ROUGHNESS(prefix)     \
COMMON_SRG_INPUTS_METALLIC(prefix)      \
COMMON_SRG_INPUTS_SPECULAR_F0(prefix)   \
COMMON_SRG_INPUTS_NORMAL(prefix)        \
COMMON_SRG_INPUTS_CLEAR_COAT(prefix)    \
COMMON_SRG_INPUTS_OCCLUSION(prefix)     \
COMMON_SRG_INPUTS_EMISSIVE(prefix)      \
COMMON_SRG_INPUTS_PARALLAX(prefix)

ShaderResourceGroup MaterialSrg : SRG_PerMaterial
{
    Texture2D m_blendMaskTexture;
    uint m_blendMaskUvIndex;
    
    // Auto-generate material SRG fields for common inputs for each layer
    DEFINE_LAYER_SRG_INPUTS(m_layer1_)
    DEFINE_LAYER_SRG_INPUTS(m_layer2_)
    DEFINE_LAYER_SRG_INPUTS(m_layer3_)
    
    float3x3 m_layer1_m_uvMatrix;
    float4 m_pad1; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.

    float3x3 m_layer2_m_uvMatrix;
    float4 m_pad2; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.

    float3x3 m_layer3_m_uvMatrix;
    float4 m_pad3; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    
    uint m_parallaxUvIndex;

    // These are used to limit the heightmap intersection search range to the narrowest band possible, to give the best quality result.
    float m_displacementMin; // The lowest displacement value possible from all layers combined (negative values are below the surface)
    float m_displacementMax; // The highest displacement value possible from all layers combined (negative values are below the surface)

    float3x3 m_uvMatrix;
    float4 m_pad4; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    float3x3 m_uvMatrixInverse;
    float4 m_pad5; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    
    Sampler m_sampler
    {
        AddressU = Wrap;
        AddressV = Wrap;
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        MaxAnisotropy = 16;
    };

    Texture2D m_brdfMap;

    Sampler m_samplerBrdf
    {
        AddressU = Clamp;
        AddressV = Clamp;
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
    };

    // Parameters for subsurface scattering
    float m_subsurfaceScatteringFactor;
    float m_subsurfaceScatteringQuality;
    float3 m_scatterDistance;
    Texture2D m_subsurfaceScatteringInfluenceMap;
    uint m_subsurfaceScatteringInfluenceMapUvIndex;

    // Parameters for transmission
    
    // Elements of m_transmissionParams:
    // Thick object mode: (attenuation coefficient, power, distortion, scale)
    // Thin  object mode:  (float3 scatter distance, scale)
    float4 m_transmissionParams;
    
    // (float3 TintColor, thickness)
    float4 m_transmissionTintThickness;
    Texture2D m_transmissionThicknessMap;
    uint m_transmissionThicknessMapUvIndex;
}

// ------ Shader Options ----------------------------------------

enum class DebugDrawMode { None, BlendWeights, DisplacementMaps };
option DebugDrawMode o_debugDrawMode;

enum class LayerBlendSource { BlendMask, VertexColors, Displacement, Fallback };
option LayerBlendSource o_layerBlendSource;

// Indicates whether the vertex input struct's "m_optional_blendMask" is bound. If false, it is not safe to read from m_optional_blendMask.
// This option gets set automatically by the system at runtime; there is a soft naming convention that associates it with m_optional_blendMask.
// (search "m_optional_" in ShaderVariantAssetBuilder for details on the naming convention).
// [GFX TODO][ATOM-14475]: Come up with a more elegant way to associate the isBound flag with the input stream.
option bool o_blendMask_isBound;

// ------ Blend Utilities ----------------------------------------

//! Returns the LayerBlendSource that will actually be used when rendering (not necessarily the same LayerBlendSource specified by the user)
LayerBlendSource GetFinalLayerBlendSource()
{    
    if(o_layerBlendSource == LayerBlendSource::BlendMask)
    {
        return LayerBlendSource::BlendMask;
    }
    else if(o_layerBlendSource == LayerBlendSource::VertexColors)
    {
        if(o_blendMask_isBound)
        {
            return LayerBlendSource::VertexColors;
        }
        else
        {
            return LayerBlendSource::BlendMask;
        }
    }
    else if(o_layerBlendSource == LayerBlendSource::Displacement)
    {
        return LayerBlendSource::Displacement;
    }
    else
    {
        return LayerBlendSource::Fallback;
    }
}

//! Returns blend weights given the depth values for each layer
float3 GetBlendWeightsFromLayerDepthValues(float3 layerDepthValues)
{
    float highestPoint = min(layerDepthValues.x, min(layerDepthValues.y, layerDepthValues.z));
    float3 blendWeights = float3(layerDepthValues.x <= highestPoint ? 1.0 : 0.0,
                                 layerDepthValues.y <= highestPoint ? 1.0 : 0.0,
                                 layerDepthValues.z <= highestPoint ? 1.0 : 0.0);
    return blendWeights;
}

float3 GetLayerDepthValues(float2 uv, float2 uv_ddx, float2 uv_ddy);

//! Return the final blend mask values to be used for rendering, based on the available data and configuration.
//! @param vertexBlendWeights - the blend weights that came from the vertex input, relevant for LayerBlendSource::VertexColors
//! @param layerDepthValues - the per-layer depth values as provided by GetLayerDepthValues()
float3 GetBlendWeights(float2 uv, float3 vertexBlendWeights, float3 layerDepthValues)
{
    float3 blendWeightValues;

    switch(GetFinalLayerBlendSource())
    {
        case LayerBlendSource::BlendMask:
            blendWeightValues = MaterialSrg::m_blendMaskTexture.Sample(MaterialSrg::m_sampler, uv).rgb;
            break;
        case LayerBlendSource::VertexColors:
            blendWeightValues = vertexBlendWeights;
            break;
        case LayerBlendSource::Displacement:
            blendWeightValues = GetBlendWeightsFromLayerDepthValues(layerDepthValues);
            break;
        case LayerBlendSource::Fallback:
            blendWeightValues = float3(1,1,1);
            break;
    }

    blendWeightValues = blendWeightValues / (blendWeightValues.r + blendWeightValues.g + blendWeightValues.b);

    return blendWeightValues;
}

//! Return the final blend mask values to be used for rendering, based on the available data and configuration.
//! Note this will sample the displacement maps in the case of LayerBlendSource::Displacement. If you have already
//! called GetLayerDepthValues(), use the GetBlendWeights() overlad that takes layerDepthValues instead.
float3 GetBlendWeights(float2 uv, float3 vertexBlendWeights)
{
    float3 layerDepthValues = float3(0,0,0);

    if(GetFinalLayerBlendSource() == LayerBlendSource::Displacement)
    {
        layerDepthValues = GetLayerDepthValues(uv, ddx_fine(uv), ddy_fine(uv));
    }

    return GetBlendWeights(uv, vertexBlendWeights, layerDepthValues);
}

float BlendLayers(float layer1, float layer2, float layer3, float3 blendWeightValues)
{
    return dot(float3(layer1, layer2, layer3), blendWeightValues);
}
float2 BlendLayers(float2 layer1, float2 layer2, float2 layer3, float3 blendWeightValues)
{
    return layer1 * blendWeightValues.r + layer2 * blendWeightValues.g + layer3 * blendWeightValues.b;
}
float3 BlendLayers(float3 layer1, float3 layer2, float3 layer3, float3 blendWeightValues)
{
    return layer1 * blendWeightValues.r + layer2 * blendWeightValues.g + layer3 * blendWeightValues.b;
}

// ------ Parallax Utilities ----------------------------------------

bool ShouldHandleParallax()
{
    // Parallax mapping's non uniform uv transformations break screen space subsurface scattering, disable it when subsurface scattering is enabled.
    // Also, all the debug draw modes avoid parallax (they early-return before parallax code actually) so you can see exactly where the various maps appear on the surface UV space.
    return !o_enableSubsurfaceScattering && o_parallax_feature_enabled && o_debugDrawMode == DebugDrawMode::None;
}

bool ShouldHandleParallaxInDepthShaders()
{
    // The depth pass shaders need to calculate parallax when the result could affect the depth buffer (or when
    // parallax could affect texel clipping but we don't have alpha/clipping support in multilayer PBR).
    return ShouldHandleParallax() && o_parallax_enablePixelDepthOffset;
}

// These static values are used to pass extra data to the GetDepth callback function during the parallax depth search.
static float3 s_blendWeightsFromVertexStream;

//! Setup static variables that are needed by the GetDepth callback function
//! @param vertexBlendWeights - the blend weights from the vertex input stream.
void GetDepth_Setup(float3 vertexBlendWeights)
{
    s_blendWeightsFromVertexStream = vertexBlendWeights;
}

//! Returns the depth values for each layer 
float3 GetLayerDepthValues(float2 uv, float2 uv_ddx, float2 uv_ddy)
{
    float3 layerDepthValues = float3(0,0,0);

    if(o_layer1_o_useDepthMap)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer1_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.r = SampleDepthOrHeightMap(MaterialSrg::m_layer1_m_depthInverted, MaterialSrg::m_layer1_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.r *= MaterialSrg::m_layer1_m_depthFactor;
        layerDepthValues.r -= MaterialSrg::m_layer1_m_depthOffset;
    }
    
    if(o_layer2_o_useDepthMap)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer2_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.g = SampleDepthOrHeightMap(MaterialSrg::m_layer2_m_depthInverted, MaterialSrg::m_layer2_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.g *= MaterialSrg::m_layer2_m_depthFactor;
        layerDepthValues.g -= MaterialSrg::m_layer2_m_depthOffset;
    }
    
    if(o_layer3_o_useDepthMap)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer3_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.b = SampleDepthOrHeightMap(MaterialSrg::m_layer3_m_depthInverted, MaterialSrg::m_layer3_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.b *= MaterialSrg::m_layer3_m_depthFactor;
        layerDepthValues.b -= MaterialSrg::m_layer3_m_depthOffset;
    }

    return layerDepthValues;
}

//! Callback function for ParallaxMapping.azsli
DepthResult GetDepth(float2 uv, float2 uv_ddx, float2 uv_ddy)
{
    float3 layerDepthValues = GetLayerDepthValues(uv, uv_ddx, uv_ddy);
    
    // Note, when the blend source is LayerBlendSource::VertexColors, parallax will not be able to blend correctly between layers. It will end up using the same blend mask values
    // for every UV position when searching for the intersection. This leads to smearing artifacts at the transition point, but these won't be so noticeable as long as
    // you have a small depth factor relative to the size of the blend transition.
    float3 blendWeightValues = GetBlendWeights(uv, s_blendWeightsFromVertexStream, layerDepthValues);

    float depth = BlendLayers(layerDepthValues.r, layerDepthValues.g, layerDepthValues.b, blendWeightValues);
    return DepthResultAbsolute(depth);
}
