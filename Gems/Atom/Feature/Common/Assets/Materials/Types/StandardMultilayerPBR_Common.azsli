/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once 

#include <Atom/Features/SrgSemantics.azsli>
#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>
#include <Atom/Features/PBR/LightingOptions.azsli>

#include "MaterialInputs/BaseColorInput.azsli"
#include "MaterialInputs/RoughnessInput.azsli"
#include "MaterialInputs/MetallicInput.azsli"
#include "MaterialInputs/SpecularInput.azsli"
#include "MaterialInputs/NormalInput.azsli"
#include "MaterialInputs/ClearCoatInput.azsli"
#include "MaterialInputs/OcclusionInput.azsli"
#include "MaterialInputs/EmissiveInput.azsli"
#include "MaterialInputs/ParallaxInput.azsli"
#include "MaterialInputs/UvSetCount.azsli"

// ------ ShaderResourceGroup ----------------------------------------

#define DEFINE_LAYER_SRG_INPUTS(prefix) \
COMMON_SRG_INPUTS_BASE_COLOR(prefix)    \
COMMON_SRG_INPUTS_ROUGHNESS(prefix)     \
COMMON_SRG_INPUTS_METALLIC(prefix)      \
COMMON_SRG_INPUTS_SPECULAR_F0(prefix)   \
COMMON_SRG_INPUTS_NORMAL(prefix)        \
COMMON_SRG_INPUTS_CLEAR_COAT(prefix)    \
COMMON_SRG_INPUTS_OCCLUSION(prefix)     \
COMMON_SRG_INPUTS_EMISSIVE(prefix)      \
COMMON_SRG_INPUTS_PARALLAX(prefix)

ShaderResourceGroup MaterialSrg : SRG_PerMaterial
{
    Texture2D m_blendMaskTexture; 
    uint m_blendMaskUvIndex;
    
    // Auto-generate material SRG fields for common inputs for each layer
    DEFINE_LAYER_SRG_INPUTS(m_layer1_)
    DEFINE_LAYER_SRG_INPUTS(m_layer2_)
    DEFINE_LAYER_SRG_INPUTS(m_layer3_)
    
    float3x3 m_layer1_m_uvMatrix;
    float4 m_pad1; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.

    float3x3 m_layer2_m_uvMatrix;
    float4 m_pad2; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.

    float3x3 m_layer3_m_uvMatrix;
    float4 m_pad3; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    
    uint m_parallaxUvIndex;

    // These are used to limit the heightmap intersection search range to the narrowest band possible, to give the best quality result.
    float m_displacementMin; // The lowest displacement value possible from all layers combined (negative values are below the surface)
    float m_displacementMax; // The highest displacement value possible from all layers combined (negative values are below the surface)

    float3x3 m_uvMatrix;
    float4 m_pad4; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    float3x3 m_uvMatrixInverse;
    float4 m_pad5; // [GFX TODO][ATOM-14595] This is a workaround for a data stomping bug. Remove once it's fixed.
    
    Sampler m_sampler
    {
        AddressU = Wrap;
        AddressV = Wrap;
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        MaxAnisotropy = 16;
    };

    Texture2D m_brdfMap;

    Sampler m_samplerBrdf
    {
        AddressU = Clamp;
        AddressV = Clamp;
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
    };

}

// ------ Shader Options ----------------------------------------

enum class DebugDrawMode { None, BlendSource, DisplacementMaps };
option DebugDrawMode o_debugDrawMode;

enum class LayerBlendSource { BlendMask, VertexColors, Displacement, Fallback };
option LayerBlendSource o_layerBlendSource;

// Indicates whether the vertex input struct's "m_optional_blendMask" is bound. If false, it is not safe to read from m_optional_blendMask.
// This option gets set automatically by the system at runtime; there is a soft naming convention that associates it with m_optional_blendMask.
// (search "m_optional_" in ShaderVariantAssetBuilder for details on the naming convention).
// [GFX TODO][ATOM-14475]: Come up with a more elegant way to associate the isBound flag with the input stream.
option bool o_blendMask_isBound;

// ------ Blend Utilities ----------------------------------------
// This is mainly used to pass extra data to the GetDepth callback function during the parallax depth search.
// But since we have it, we use it in some other functions as well rather than passing it around.
static float3 s_blendMaskFromVertexStream;

//! Returns the LayerBlendSource that will actually be used when rendering (not necessarily the same LayerBlendSource specified by the user)
LayerBlendSource GetFinalLayerBlendSource()
{    
    if(o_layerBlendSource == LayerBlendSource::BlendMask)
    {
        return LayerBlendSource::BlendMask;
    }
    else if(o_layerBlendSource == LayerBlendSource::VertexColors)
    {
        if(o_blendMask_isBound)
        {
            return LayerBlendSource::VertexColors;
        }
        else
        {
            return LayerBlendSource::BlendMask;
        }
    }
    else if(o_layerBlendSource == LayerBlendSource::Displacement)
    {
        return LayerBlendSource::Displacement;
    }
    else
    {
        return LayerBlendSource::Fallback;
    }
}

//! Return the raw blend source values directly from the blend mask or vertex colors, depending on the available data and configuration.
//!     layer1 is an implicit base layer
//!     layer2 is weighted by r
//!     layer3 is weighted by g
//!     b is reserved for perhaps a dedicated puddle layer
float3 GetBlendSourceValues(float2 uv)
{
    float3 blendSourceValues = float3(0,0,0);

    if(o_layer2_enabled || o_layer3_enabled)
    {
        switch(GetFinalBlendMaskSource())
        {
            case BlendMaskSource::TextureMap:
                blendSourceValues = MaterialSrg::m_blendMaskTexture.Sample(MaterialSrg::m_sampler, uv).rgb;
                break;
            case BlendMaskSource::VertexColors:
                blendSourceValues = s_blendMaskFromVertexStream;
                break;
        }

        if(!o_layer2_enabled)
        {
            blendSourceValues.r = 0.0;
        }

        if(!o_layer3_enabled)
        {
            blendSourceValues.g = 0.0;
        }
    }

    return blendSourceValues;
}

//! Returns blend weights given the depth values for each layer
//! @param layerDepthValues - the per-layer depth values as provided by GetLayerDepthValues()
float3 GetBlendWeightsFromLayerDepthValues(float3 layerDepthValues)
{
    float highestPoint = min(layerDepthValues.x, min(layerDepthValues.y, layerDepthValues.z));
    float3 blendWeights = float3(layerDepthValues.x <= highestPoint ? 1.0 : 0.0,
                                 layerDepthValues.y <= highestPoint ? 1.0 : 0.0,
                                 layerDepthValues.z <= highestPoint ? 1.0 : 0.0);
    return blendWeights;
}

float3 GetLayerDepthValues(float2 uv, float2 uv_ddx, float2 uv_ddy);

//! Return the final blend mask values to be used for rendering, based on the available data and configuration.
//! @return The blend weights for each layer.
//!         Even though layer1 not explicitly specified in the blend source data, it is explicitly included with the returned values.
//!         layer1 = r
//!         layer2 = g
//!         layer3 = b
float3 GetBlendWeights(float2 uv)
{
    float3 blendWeights;
    
    if(o_layer2_enabled || o_layer3_enabled)
    {
        float3 blendSourceValues = GetBlendSourceValues(uv);

        // Calculate blend weights such that multiplying and adding them with layer data is equivalent
        // to lerping between each layer.
        //     final = lerp(final, layer1, blendWeights.r)
        //     final = lerp(final, layer2, blendWeights.g)
        //     final = lerp(final, layer3, blendWeights.b)

        blendWeights.b = blendSourceValues.g;
        blendWeights.g = (1.0 - blendSourceValues.g) * blendSourceValues.r;
        blendWeights.r = (1.0 - blendSourceValues.g) * (1.0 - blendSourceValues.r);
    }
    else
    {
        blendWeights = float3(1,0,0);
    }

    return blendWeights;
}

//! Return the final blend mask values to be used for rendering, based on the available data and configuration.
//! Note this will sample the displacement maps in the case of LayerBlendSource::Displacement. If you have already
//! called GetLayerDepthValues(), use the GetBlendWeights() overlad that takes layerDepthValues instead.
float3 GetBlendWeights(float2 uv, float3 vertexBlendWeights)
{
    float3 layerDepthValues = float3(0,0,0);

    if(GetFinalLayerBlendSource() == LayerBlendSource::Displacement)
    {
        layerDepthValues = GetLayerDepthValues(uv, ddx_fine(uv), ddy_fine(uv));
    }

    return GetBlendWeights(uv, vertexBlendWeights, layerDepthValues);
}

float BlendLayers(float layer1, float layer2, float layer3, float3 blendWeights)
{
    return dot(float3(layer1, layer2, layer3), blendWeights);
}
float2 BlendLayers(float2 layer1, float2 layer2, float2 layer3, float3 blendWeights)
{
    return layer1 * blendWeights.r + layer2 * blendWeights.g + layer3 * blendWeights.b;
}
float3 BlendLayers(float3 layer1, float3 layer2, float3 layer3, float3 blendWeights)
{
    return layer1 * blendWeights.r + layer2 * blendWeights.g + layer3 * blendWeights.b;
}

// ------ Parallax Utilities ----------------------------------------

bool ShouldHandleParallax()
{
    // Parallax mapping's non uniform uv transformations break screen space subsurface scattering, disable it when subsurface scattering is enabled.
    // Also, all the debug draw modes avoid parallax (they early-return before parallax code actually) so you can see exactly where the various maps appear on the surface UV space.
    return !o_enableSubsurfaceScattering && o_parallax_feature_enabled && o_debugDrawMode == DebugDrawMode::None;
}

bool ShouldHandleParallaxInDepthShaders()
{
    // The depth pass shaders need to calculate parallax when the result could affect the depth buffer (or when
    // parallax could affect texel clipping but we don't have alpha/clipping support in multilayer PBR).
    return ShouldHandleParallax() && o_parallax_enablePixelDepthOffset;
}

//! Returns the depth values for each layer 
float3 GetLayerDepthValues(float2 uv, float2 uv_ddx, float2 uv_ddy)
{
    float3 layerDepthValues = float3(0,0,0);

    if(o_layer1_o_useDepthMap)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer1_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.r = SampleDepthOrHeightMap(MaterialSrg::m_layer1_m_depthInverted, MaterialSrg::m_layer1_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.r *= MaterialSrg::m_layer1_m_depthFactor;
        layerDepthValues.r -= MaterialSrg::m_layer1_m_depthOffset;
    }
    
    if(o_layer2_enabled && o_layer2_o_useDepthMap)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer2_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.g = SampleDepthOrHeightMap(MaterialSrg::m_layer2_m_depthInverted, MaterialSrg::m_layer2_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.g *= MaterialSrg::m_layer2_m_depthFactor;
        layerDepthValues.g -= MaterialSrg::m_layer2_m_depthOffset;
    }
    
    if(o_layer3_enabled && o_layer3_o_useDepthMap)
    {
        float2 layerUv = uv;
        if(MaterialSrg::m_parallaxUvIndex == 0)
        {
            layerUv = mul(MaterialSrg::m_layer3_m_uvMatrix, float3(uv, 1.0)).xy;
        }

        layerDepthValues.b = SampleDepthOrHeightMap(MaterialSrg::m_layer3_m_depthInverted, MaterialSrg::m_layer3_m_depthMap, MaterialSrg::m_sampler, layerUv, uv_ddx, uv_ddy).m_depth;
        layerDepthValues.b *= MaterialSrg::m_layer3_m_depthFactor;
        layerDepthValues.b -= MaterialSrg::m_layer3_m_depthOffset;
    }

    return layerDepthValues;
}

//! Callback function for ParallaxMapping.azsli
DepthResult GetDepth(float2 uv, float2 uv_ddx, float2 uv_ddy)
{
    float3 layerDepthValues = GetLayerDepthValues(uv, uv_ddx, uv_ddy);
    
    // Note, when the blend source is LayerBlendSource::VertexColors, parallax will not be able to blend correctly between layers. It will end up using the same blend mask values
    // for every UV position when searching for the intersection. This leads to smearing artifacts at the transition point, but these won't be so noticeable as long as
    // you have a small depth factor relative to the size of the blend transition.
    float3 blendWeightValues = GetBlendWeights(uv, s_blendWeightsFromVertexStream, layerDepthValues);

    float depth = BlendLayers(layerDepthValues.r, layerDepthValues.g, layerDepthValues.b, blendWeightValues);
    return DepthResultAbsolute(depth);
}
